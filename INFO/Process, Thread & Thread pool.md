---
created: 2025-02-07-12-48-14+10:00
tags:
---
В C# концепция потоков (thread) и пулов потоков (thread pool) играют важную роль в управлении многопоточностью и параллельными вычислениями.

Поток — это основная единица обработки, которая выполняет определённый набор инструкций. В C# потоки можно создавать с помощью класса `Thread`. Каждый поток имеет своё собственное состояние и стек, что позволяет выполнять несколько операций одновременно. Тем не менее, управление потоками на низком уровне может быть сложным и требует значительных ресурсов, особенно если необходимо создавать и уничтожать большое количество потоков.

Чтобы упростить работу с многопоточностью и оптимизировать производительность, в C# был создан пул потоков (thread pool). Пул потоков представляет собой коллекцию заранее созданных потоков, которые могут быть повторно использованы для выполнения различных задач. Вместо того чтобы создавать новый поток при каждой задаче, задачи помещаются в очередь, и уже существующие потоки из пула берут их на выполнение. Это снижает накладные расходы, связанные с созданием и уничтожением потоков.

Использование пула потоков позволяет разработчикам концентрироваться на логике приложения, не заботясь о том, как управлять потоками непосредственно. Пул потоков также более эффективно распределяет ресурсы, что может привести к лучшей производительности, особенно в приложениях с большим количеством параллельных задач.

В C# для работы с пулом потоков можно использовать класс `ThreadPool`, который предлагает такой API, как `QueueUserWorkItem`, позволяющий ставить задачи в очередь на выполнение в пуле.

В заключение, потоки и пул потоков в C# позволяют разработчикам эффективно организовывать и управлять многопоточными операциями, оптимизируя производительность и упрощая программирование.

https://gist.github.com/ghuntley/e5b5642ecc4428255e61185bb79856e4

- **Процессом** является программа _в момент выполнения._ В обычное время ваша программа является просто набором инструкций, хранящимся в файле на жестком диске. Процессом программа становится, когда выгружается с жёсткого диска в оперативную память на выполнение.
- **Поток** — это наименьшая единица обработки информации, которую может выделить операционная система. Поток в большинстве случаев находится внутри процесса и является его подмножеством. Поток представлен классом _Thread._
- Несколько потоков могут создаваться и существовать **внутри одного процесса**, совместно использовать ресурсы, выделенные этому процессу операционной системой (например, память, в которой хранятся значения переменных). Это вы уже могли наблюдать, когда обращались к одним и тем же глобальным переменным из разных потоков.
# Process and Thread
- Одна программа на старте всегда является **одним отдельным процессом** (со своим отдельным адресным пространством памяти). Процесс может запускать дополнительные процессы, но не может напрямую ими управлять и получить доступ к их адресному пространству.
- Процессы бывают **системные** и **пользовательские**, в зависимости от того, как и кем они запущены.
- В зависимости от типа процесса он имеет или не имеет права на определенные действия (запись/чтение из различных директорий, удаление файлов и т.д.).
- Процесс в ОС имеет свой уникальный идентификатор — **PID.**
- В рамках одного процесса (программы) может существовать **один или несколько потоков**.
- Если в программе выполняется один управляемый поток (не считая сервисных потоков среды CLR), мы говорим об однопоточном приложении. Если несколько — это приложение многопоточное.
- Поток может быть запущен с помощью вызова метода **[Thread.Start()](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.thread.start?view=net-6.0)**.
# Thread
Давайте зафиксируем основные возможности класса `Thread`:
- Позволяет создавать отдельные потоки выполнения на уровне операционной системы.
- Позволяет создание фоновых _(background)_ и обычных потоков при помощи свойства **[Thread.IsBackground](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.thread.isbackground?view=net-5.0)**. Основное отличие в том, что фоновый поток завершается вместе с порождающим его основным потоком.
- Предоставляет возможность назначить потоку приоритет при помощи свойства **[Thread.Priority](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.thread.priority?view=net-5.0)**. Значения этого свойства будут учитываться операционной системой при исполнении вашего кода. Однако установленный здесь приоритет для операционной системы носит все же рекомендательный характер. Возможны следующие приоритеты потоков: `Lowest`, `BelowNormal`, `Normal`, `AboveNormal`, `Highest`. По умолчанию поток имеет приоритет `Normal`.
- Позволяет вам узнать текущее состояние потока с помощью свойства **[ThreadState](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.threadstate?view=net-5.0)**.
- Позволяет получить ссылку на текущий исполняемый поток при помощи свойства **[Thread.CurrentThread](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.thread.currentthread?view=net-5.0).** К примеру, если внутри метода `Main()` мы вызовем: `var currentThread = Thread.CurrentThread;`. То мы получим ссылку на текущий основной поток выполнения, который есть в каждой программе.
- Класс **[Thread](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.thread?view=net-5.0)** имеет модификатор `sealed`, поэтому мы не можем унаследовать его.
