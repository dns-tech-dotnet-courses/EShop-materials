---
created: 2025-01-31-15-28-41+10:00
tags:
---
Эта архитектура, включающая **Presentation Layer (UI)**, **Application Layer**, **Domain Layer** и **Data Access Layer (DAL)**, часто используется в **Domain-Driven Design (DDD)** и более сложных системах. Она обеспечивает чёткое разделение ответственности и подходит для проектов с насыщенной бизнес-логикой. Разберём каждый слой:

---

### 1. **Presentation Layer (Слой представления)**

**Роль**: Взаимодействие с пользователем или внешними системами.**Что включает**:

- Интерфейсы: веб-приложения (React, Angular), мобильные приложения, API (REST/gRPC).
    
- Преобразует данные из формата слоя приложения (Application Layer) в формат, понятный пользователю (HTML, JSON, XML).
    
- Обрабатывает ввод (валидация, преобразование) и передаёт его в Application Layer.
    

**Пример**:Контроллер в ASP.NET Core, принимающий HTTP-запрос и вызывающий сервис из Application Layer.

### 2. **Application Layer (Слой приложения)**

**Роль**: Координация бизнес-процессов и оркестрация операций.**Что включает**:

- Управление **use case** (сценариями использования): регистрация пользователя, оформление заказа.
    
- Работа с транзакциями, координация между Domain Layer и инфраструктурой (например, отправка email через Infrastructure Layer).
    
- **Не содержит бизнес-логики** — делегирует её Domain Layer.
    

**Пример**:Сервис `OrderService`, который:

1. Получает запрос на создание заказа из Presentation Layer.
    
2. Вызывает Domain Layer для проверки правил (например, достаточно ли товара на складе).
    
3. Сохраняет заказ через DAL.
    
4. Запускает уведомление через Infrastructure Layer (например, отправка email).
    

### 3. **Domain Layer (Доменный слой)**

**Роль**: Сердце системы — реализация бизнес-логики и правил предметной области.**Что включает**:

- **Сущности (Entities)**: Объекты с идентичностью и состоянием (например, `User`, `Order`).
    
- **Value Objects**: Неизменяемые объекты без идентичности (например, `Address`, `Money`).
    
- **Агрегаты (Aggregates)**: Группы связанных сущностей, управляемые как единое целое.
    
- **Domain Services**: Сервисы для операций, которые не принадлежат конкретной сущности (например, `PaymentCalculator`).
    
- **Репозитории (интерфейсы)**: Определяют контракты для работы с данными (реализуются в DAL).
    

**Пример**:Метод `Order.Validate()` проверяет, что заказ содержит хотя бы один товар и корректный адрес доставки.

### 4. **Data Access Layer (DAL)**

**Роль**: Работа с данными и инфраструктурой.**Что включает**:

- Реализация репозиториев из Domain Layer (например, `OrderRepository`).
    
- Взаимодействие с БД (SQL, NoSQL), файлами, внешними API.
    
- Использование ORM (Entity Framework, Hibernate) или raw SQL.
    

**Пример**:Класс `OrderRepositoryEF`, который с помощью Entity Framework сохраняет заказ в PostgreSQL.

### Как слои взаимодействуют?

1. **Presentation Layer** → **Application Layer**:Запросы передаются в виде DTO (Data Transfer Objects).
    
2. **Application Layer** → **Domain Layer**:Вызывает доменные сервисы, сущности и агрегаты для выполнения бизнес-логики.
    
3. **Domain Layer** ↔ **DAL**:Domain Layer зависит только от интерфейсов репозиториев, а DAL предоставляет их реализацию.
    
4. **DAL** → Базы данных/внешние системы:Выполняет запросы и преобразует данные в объекты Domain Layer.
    

---

### Пример потока: Создание заказа

1. Пользователь нажимает «Оформить заказ» в **Presentation Layer** (веб-интерфейс).
    
2. **Application Layer** (например, `OrderAppService`):
    
    - Получает DTO с данными заказа.
        
    - Вызывает `Order.Create()` из **Domain Layer** для валидации.
        
    - Сохраняет заказ через `IOrderRepository` (реализованный в **DAL**).
        
    - Запускает отправку уведомления через инфраструктурный сервис.
        
3. **DAL** сохраняет заказ в БД через Entity Framework.
    

---

### Ключевые принципы

- **Инверсия зависимостей (Dependency Inversion)**:Domain Layer не зависит от DAL — вместо этого DAL реализует интерфейсы, определённые в Domain Layer.
    
- **Чистая доменная модель**:Domain Layer не содержит технических деталей (например, код работы с БД).
    
- **Слоистая изоляция**:Изменения в Presentation Layer (например, переход с React на Angular) не затрагивают Domain Layer.
    

---

### Преимущества

- Чёткое разделение бизнес-логики (Domain Layer) и технических деталей (DAL).
    
- Упрощение тестирования (можно мокать DAL при тестировании Domain Layer).
    
- Гибкость: замена инфраструктуры (например, переход с MySQL на MongoDB) затрагивает только DAL.
    

---

### Когда использовать?

- Для сложных систем с насыщенной бизнес-логикой (финансы, e-commerce).
    
- В проектах, где важна долгосрочная поддерживаемость и масштабируемость.
    
- При использовании Domain-Driven Design (DDD).
    

Эта архитектура требует больше boilerplate-кода, но окупается в проектах высокой сложности.