# Создаем решение

Запускаем Visual Studio 2022  
Создаем проект

![](attachments/Pasted%20image%2020250130205225.png)

Вводим в поиск: Веб  
Выбираем из списка Веб-API ASP.NET Core (Майкрософт)  

![](attachments/Pasted%20image%2020250130205301.png)

Имя проекта: `EShop.Presentation`
Имя решения: `EShop`

![](attachments/Pasted%20image%2020250130210040.png)

Снимаем галку Настроить для HTTPS  

![](attachments/Pasted%20image%2020250130210112.png)

Сразу запустим наше приложение  

![](attachments/Pasted%20image%2020250130223621.png)

Открылась консоль и браузер:

![](attachments/Pasted%20image%2020250130223732.png)

Протестируем работу API-метода

![](attachments/Pasted%20image%2020250130224032.png)

В Curl: видим какой запрос был отправлен из браузера на наш локальный сервер  
Ниже видим какой ответ от сервера был получен.

# Содержимое проекта

Шаблон который мы выбрали создает файлы в проекте, которые позволяют не написав и строки кода посмотреть работу dotnet API.  
Рассмотрим элементы созданного решения.  
Обратимся к панели `Обозреватель решений`  

![](attachments/Pasted%20image%2020250130215130.png)

1. Решение "EShop" - контейнер для организации нескольких связанных проектов в единую структуру.  
2. Проект "EShop.Presentation" - отдельный компонент приложения (например: библиотека, веб-API, консольное приложение).  
3. Папка Properties. Содержит файл `launchSettings.json`, который хранит настройки запуска и среды для ASP.NET Core приложений, определяя параметры вроде URL-портов, переменных окружения и профилей отладки (например, Development/Production). Он упрощает управление конфигурациями при локальной разработке, позволяя быстро переключаться между сценариями без изменения кода.  
4. Раздел "Зависимости" в обозревателе решений .NET отображает все внешние компоненты, от которых зависит проект. Он включает:  
   - NuGet-пакеты — сторонние библиотеки, добавленные через менеджер пакетов.  
   - Ссылки на проекты — зависимости от других проектов в решении.  
   - Системные сборки — базовые библиотеки .NET (например, `System.Text.Json`).  
5. Папка Controllers и файл класса контроллера `WeatherForecastController.cs`.  
6. Файлы конфигурации приложения.  
   - `appsetings.json` - основной конфигурационный файл для хранения настроек приложения (например, строки подключения, параметры API, логирование). Используется по умолчанию.  
   - `appsettings.Development.json` - переопределяет настройки из `appsettings.json` для среды Development. Активен, когда приложение запущено в режиме разработки (переменная окружения `ASPNETCORE_ENVIRONMENT = Development`, устанавливается в `launchSettings.json`).  
7. `.http` файл `EShop.Presentation.http` - специальный файл для быстрой отладки и прототипирования http запросов.  
8. `Program.cs` - входная точка в приложение.  
9. `WeatherForecast.cs` - файл с моделью прогноза погоды, который используется `WeatherForecastController.cs`.

## Как это выглядит вне IDE

**Решение** (Solution) - контейнер для организации нескольких связанных проектов в единую структуру.  
- Файл: `.sln`  
- Объединяет проекты (например: основное приложение, тесты, библиотеки).  
- Управляет зависимостями между проектами, сборкой и настройками.  

**Проект** (Project) - отдельный компонент приложения (например: библиотека, веб-API, консольное приложение).  
- Файл: `.csproj`  
- Содержит код, настройки, зависимости (NuGet-пакеты), цели сборки.  
- Компилируется в сборку (DLL/EXE).  

В обозревателе решений: ПКМ по `Решение EShop`  

![](attachments/Pasted%20image%2020250130215506.png)  
![](attachments/Pasted%20image%2020250130221048.png)

Открываем папку `EShop.Presentation`  

![](attachments/Pasted%20image%2020250130210807.png)

[INFO bin&obj](INFO/bin&obj.md)

# Program.cs

В коде создается и конфигурируется ASP.NET Core веб-приложение с использованием OpenAPI (Swagger) через библиотеку Swashbuckle.

## Создание и настройка приложения:

```csharp
var builder = WebApplication.CreateBuilder(args);
```

Создается экземпляр `WebApplicationBuilder`, который предоставляет ключевые функции для настройки приложения. Он собирает все необходимые сервисы и конфигурации (например, зависимость DI, настройку Middleware и т.д.).

## Добавление сервисов в контейнер зависимостей:

```csharp
builder.Services.AddControllers();
```

`AddControllers()` — добавляет поддержку контроллеров (MVC или API контроллеры). Это необходимо для работы Action методов, отвечающих за обработку маршрутов.

```csharp
builder.Services.AddEndpointsApiExplorer();
```

`AddEndpointsApiExplorer()` — используется для поддержки минимальных API (например, добавляет отображение эндпоинтов, которые используются в Swagger, при их наличии). Без этого Swagger не будет корректно отображать минимальные API, если они будут добавлены.

```csharp
builder.Services.AddSwaggerGen();
```

`AddSwaggerGen()` — добавляет генератор Swagger, который будет выполнять следующие задачи:  
- Генерировать документацию в формате **OpenAPI**.  
- Предоставлять JSON-файл, описывающий все доступные маршруты API.  
- Сделать документ интерактивным через **Swagger UI**.

## Создание и настройка приложения:

```csharp
var app = builder.Build();
```

Создается экземпляр конечного веб-приложения (`WebApplication`) после конфигурирования. Это объект, который запускается как сервер ASP.NET Core.

## Настройка Middleware:

```csharp
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
```

Проверяется, находится ли приложение в среде "разработка"(Development).  
Если да:  
- `UseSwagger()` включает генерацию API-документации в служебном JSON-формате (обычно доступного по маршруту `/swagger/v1/swagger.json`).  
- `UseSwaggerUI()` — включает веб-интерфейс Swagger (доступный, например, по адресу `/swagger`). Этот UI позволяет тестировать API прямо из браузера, отправляя запросы и просматривая ответы.

### Остальные настройки Middleware:

```csharp
app.UseHttpsRedirection();
```

Все HTTP-запросы перенаправляются на HTTPS для повышения безопасности.

```csharp
app.UseAuthorization();
```

Включает поддержку авторизации. Это необходимо, если в приложении есть маршруты, регулируемые с помощью политик или атрибутов [Authorize].

## Настройка маршрутов контроллеров:

```csharp
app.MapControllers();
```

Подключает маршрутизацию для всех контроллеров. Все маршруты API, объявленные в контроллерах ([HttpGet], [HttpPost], и т.д.), начинают работать.

## Запуск приложения:

```csharp
app.Run();
```

Запускает сервер ASP.NET Core.

## Что такое Swagger/Swashbuckle?

- Swagger (теперь известный как OpenAPI) — это спецификация для описания API в удобном JSON- или YAML-формате. Swagger позволяет разработчикам легко документировать свои API и генерировать код клиентов.  
- В ASP.NET Core для реализации Swagger используется `Swashbuckle`, включающий:  
  - `Swashbuckle.AspNetCore.Swagger`: библиотека для создания JSON-файлов, описывающих API.  
  - `Swashbuckle.AspNetCore.SwaggerGen`: автоматически генерирует документацию из маршрутов, контроллеров и моделей.  
  - `Swashbuckle.AspNetCore.SwaggerUI`: визуализирует эту документацию в браузере через интерактивный интерфейс.

## Как это работает?

Добавление Swagger генерации:  
- В `builder.Services.AddSwaggerGen()` конфигурация собирает все доступные API роуты и создает JSON-документ для документации.  
- Swagger UI визуализирует JSON, предоставляя разработчикам интерфейс для тестирования.  

Настройка эндпоинта Swagger:  
- Пример JSON-документа Swagger можно увидеть по маршруту `/swagger/v1/swagger.json`.  
- Встроенный Swagger UI доступен, когда приложение работает в среде `Development`.

# WeatherForecats.cs

Класс `WeatherForecast` обычно используется для представления данных прогноза погоды. Это простой DTO (Data Transfer Object), который содержит информацию о конкретной дате и погоде, включая температуру и необязательную текстовую сводку (например, описание погоды).

#### Пространство имён

```csharp
namespace EShop.Presentation
```

Определяет `namespace` для класса. Например, пространство имён организует код в логические блоки, а в данном случае оно относится к приложению EShop.Presentation.

#### Свойства:

**Дата прогнозируемой погоды**

```csharp
public DateOnly Date { get; set; }
```

`DateOnly` — встроенный тип в .NET для работы только с датой (без времени).  
Свойство `Date` принимает или возвращает дату (например, конкретный день прогноза).

**Температура в градусах Цельсия**

```csharp
public int TemperatureC { get; set; }
```

Хранит температуру в градусах Цельсия в виде целого числа.  
Это свойство можно изменять или получать значение, чтобы отобразить прогнозируемую температуру.

**Температура в градусах Фаренгейта** (вычисляемое свойство)

```csharp
public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
```

Этот блок представляет так называемое вычисляемое свойство.  
Значение свойства `TemperatureF` вычисляется на основе формулы: [ F = 32 + \frac{C}{0.5556} ]  
Температура в Цельсиях (`TemperatureC`) автоматически пересчитывается для представления в градусах Фаренгейта.  
Это свойство **только для чтения** (не имеет `set`).

**Описание погоды**

```csharp
public string? Summary { get; set; }
```

Свойство для хранения текстового описания погоды, например, "Облачно", "Солнечно", "Дождливо".  
Знак вопроса (`?`) означает, что значение может быть `null`, что полезно, если описание погоды не указано.

# WeatherForecastController.cs

Контроллер `WeatherForecastController` отвечает за обработку HTTP-запросов, связанных с прогнозами погоды, и возвращает их клиенту в формате JSON. Это базовый пример контроллера API с использованием ASP.NET Core.

### **Пространство имен**

```csharp
namespace EShop.Presentation.Controllers
```

Этот объект находится под пространством имен `EShop.Presentation.Controllers`, что говорит нам о его размещении в проекте.

### **Атрибуты контроллера**

#### `[ApiController]`

Указывает, что текущий класс является контроллером API.  
Этот атрибут добавляет функции, такие как автоматическая проверка данных модели (Model Validation) и интеграцию работы с HTTP-запросами/ответами.

#### `[Route("[controller]")]`

Задает маршрут для этого контроллера. Значение `"[controller]"` автоматически заменяется на имя класса без суффикса "Controller", т.е. маршрут будет `/WeatherForecast`.

### **Поле** `ILogger`

```csharp
private readonly ILogger<WeatherForecastController> _logger;
```

Это инъекция зависимости для логирования. Интерфейс `ILogger<T>` позволяет записывать диагностические сообщения, ошибки или другую информацию на сервере.  
`ILogger<WeatherForecastController>` указывает на то, что журнал создается для этого конкретного контроллера.

### **Конструктор**

```csharp
public WeatherForecastController(ILogger<WeatherForecastController> logger)
{
    _logger = logger;
}
```

Контроллер получает логгер через механизм зависимости (Dependency Injection). Это позволяет использовать его в контроллере для регистрации сообщений.

### **Массив текстовых описаний погоды**

```csharp
private static readonly string[] Summaries = new[]
{
    "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
};
```

Это статический массив строк, представляющий заранее заданные описания погодных условий, такие как "Freezing" (Морозно), "Hot" (Жарко) и т.д.  
Используется для выбора случайного текста прогноза через вызовы к массиву.

### **Метод** `Get()`

#### Определение метода:

```csharp
[HttpGet(Name = "GetWeatherForecast")]
public IEnumerable<WeatherForecast> Get()
```

Этот метод имеет атрибут `[HttpGet]`, указывающий, что он будет обрабатывать HTTP GET-запросы по маршруту, заданному для контроллера.  
Он возвращает коллекцию объектов типа `IEnumerable<WeatherForecast>`.

#### Логика:

```csharp
return Enumerable.Range(1, 5).Select(index => new WeatherForecast
{
    Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
    TemperatureC = Random.Shared.Next(-20, 55),
    Summary = Summaries[Random.Shared.Next(Summaries.Length)]
})
.ToArray();
```

`Enumerable.Range(1, 5)`: Создает последовательность из 5 элементов (числа от 1 до 5), которая используется как основа для генерации данных о погоде.  
`DateOnly.FromDateTime(DateTime.Now.AddDays(index))`: Генерирует дату начиная с текущего дня, добавляя значение `index` (день 1, день 2 и т.д.).  
`Random.Shared.Next(-20, 55)`: Создает случайную температуру в диапазоне от -20°C до 55°C.  
`Summaries[Random.Shared.Next(Summaries.Length)]`: Выбирает случайное описание погоды из массива `Summaries`.  
Возвращаемая коллекция конвертируется в массив методом `.ToArray()`.

# EShop.Presentation.http

**`.http`-файлы** в шаблонах ASP.NET Core предназначены для тестирования API-эндпоинтов прямо из IDE (например, Visual Studio или VS Code). Они содержат примеры HTTP-запросов (GET, POST и др.) с параметрами, заголовками и телами, которые можно быстро отправить к вашему приложению без использования Postman, Bruno или других внешних инструментов.

**Зачем они нужны:**  
- Упрощение отладки — отправка запросов в один клик (через расширения вроде _REST Client_ для VS Code).  
- Документирование API — шаблон сразу показывает, как взаимодействовать с эндпоинтами.  
- Локальное тестирование — проверка работы контроллеров без развёртывания приложения.  

Запускаем приложение.  
Нажимаем `Отправить запрос` в .http файле.  

![](attachments/Pasted%20image%2020250130223318.png)

## VS Code REST Client

[Устанавливаем VS Code](https://code.visualstudio.com/)  
[Устанавливаем REST client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client)  

![](attachments/Pasted%20image%2020250130222655.png)

В VS Code переходим File - Open folder (Ctrl+K Ctrl +O). Выбираем директорию нашего решения.  
Запускаем приложение в Visual Studio.  
Кликаем Send Request.  

![](attachments/Pasted%20image%2020250130222958.png)

Обратим внимание на то откуда берется порт  

![](attachments/Pasted%20image%2020250130224213.png)

Попробуем еще один способ отправки.  
Вернемся в VS Code  
Создадим новый файл на рабочем столе  
Выберем расширение .http  

![](attachments/Pasted%20image%2020250130224405.png)

Напишем такой код  
`GET http://localhost:5038/weatherforecast/`  
Запустим наше приложение в Visual Studio и нажмем Send Request  

![](attachments/Pasted%20image%2020250130224605.png)

Получили ответ от сервера. Таким образом мы эмулировали условно-внешнее клиентское обращение к нашему приложению.

# Разбираемся с GIT

Git должен был установится при установке Visual Studio  
[INFO Установить и настроить Git](INFO/Установить%20и%20настроить%20Git.md)  
Сейчас для нашего решения не существует репозитория Git.  
Мы начнем с создания локального репозитория и потом на основе локального репозитория создадим удаленный репозиторий в GitHub.  
Мы будем создавать репозиторий с помощью встроенный в Visual Studio графический клиент для Git.

**Локальный Git-репозиторий** — это папка на вашем компьютере, в которой Git создает специальные служебные файлы. Git отслеживает все изменения файлов проекта. Вы правите файл в папке в блокноте, git фиксирует это у себя в служебных файлах.  
Содержит в себе:  
- Историю версий (коммиты) с датами, авторами и описаниями.  
- Скрытую папку `.git` — база данных с метаданными и изменениями.  
- Ветки для параллельной работы над разными задачами.

**Создать с помощью терминала:**  
`git init` — превращает текущую папку в репозиторий. Когда в папке вызывается эта команда в ней создаются служебные файлы, с помощью которых git осуществляет фиксацию изменений. Наличие этих файлов и говорит о том, что это git репозиторий.  
`git clone` — копирует удаленный репозиторий на ваш ПК.  

**Удаленный Git репозиторий** - это версия вашего проекта, хранящаяся на сервере или в облачном сервисе (например, GitHub, GitLab, Bitbucket).  
Удаленный репозиторий нужен для совместной работы надо кодом, бэкапа кода, и различных deploy активностей. Позже в курсе, мы подробнее рассмотрим эти аспекты работы с Git.

## Git репозитории для EShop

Мы создадим локальный репозиторий и сразу свяжем его с удаленным репозиторием  
Откроем изменения Git:  

![](attachments/Pasted%20image%2020250131094942.png)

Мы будем хранить удаленный репозиторий внутри "Организации" - это сущность GitHub, для работы с разными репозиториями в пределах какой-то общности людей. Например группы людей с курсов.  

![](attachments/Pasted%20image%2020250131101430.png)

1. Путь к локальному git-репозиторию. В этой папке будет выполнен `git init`.  
2. Шаблон `GITIGNORE` - чтобы не отслеживать служебные файлы, git использует специальный файл `.gitignore` в нем перечисляются маски или имена файлов, которые git не будет отслеживать при изменении. В данном случае выбирая шаблон - visual studio сам создаст и заполнит за нас такой файл.  
3. Учетная запись - ваша учетная запись, с которой вы получили доступ в организацию курса.  
4. Владелец - здесь нужно выбрать организацию, тогда репозиторий будет создан в хранилище репозиториев организации курса  
5. Имя репозитория - нужно назвать по шаблону `Фамилия-EShop`, фамилия транслитом  
6. Видимость `public`.  
7. Здесь отображается какой адрес удалённого репозитория будет сопоставлен этому локальному репозиторию.  
8. Нажимаем `Создать и отправить`  

После этого Visual Studio за нас выполнит команды:  
`git init` - инициализирует пустой репозиторий в текущей папке проекта. Создаёт скрытую папку `.git` с метаданными.  
`git add` - добавляет все файлы проекта в индекс (staging area) для подготовки к коммиту.  
`git commit` - сохраняет текущее состояние файлов в истории репозитория с комментарием "Initial commit".  
`git remote add origin [URL_удалённого_репозитория]` - добавляет удалённый репозиторий под именем `origin` (стандартное имя для основной удалённой копии). В нашем случае это `7`, на скриншоте.  
`git push -u origin main` - отправляет локальные коммиты в ветку `master`. Флаг `-u` связывает локальную ветку с удалённой для упрощения будущих `git push/pull`.  

После нажатия кнопки, нужно немного подождать т.к. должны выполнится указанные операции.  
Открываем "Изменения Git".  

![](attachments/Pasted%20image%2020250131103212.png)

1. Нажимаем "Просмотреть все фиксации"  
2. Локальный репозиторий  
3. Удаленный репозиторий  
4. Коммиты в репозиторий решения  

Переходим по ссылке https://github.com/orgs/dns-tech-dotnet-courses/repositories  
Видим в списке наш репозиторий  

![](attachments/Pasted%20image%2020250131103310.png)

Проваливаемся в него  
Видим коммиты  

![](attachments/Pasted%20image%2020250131103353.png)

Это репозиторий в котором мы будем делать сквозной проект на протяжении курса.  
Есть разные схемы работы с ветками в Git.  
У нас будет такой флоу - на каждом занятии создаем новую ветку от master. Делаем совместную работу, сливаем ветку в master.  
Рассмотрим как это сделать.  

![](attachments/Pasted%20image%2020250131103711.png)

Будем использовать схему именования  
`cw-номер-занятия` для классной работы  
`hw-номер-занятия` для домашней работы  

Видим, что мы сейчас находимся на ветке `cw-01`  

![](attachments/Pasted%20image%2020250131103836.png)

Сейчас все наши изменения будут фиксироваться в привязке к ветке `cw-01`, если мы изменим и сделаем коммит, а потом перейдём на `master` - изменения сохраняться только в ветке `cw-01`, в `master` изменений не будет.  
Проверим это.  
Открываем `EShop\EShop.Presentation\Controllers\WeatherForecastController.cs`  
Удалим код `(Name = "GetWeatherForecast")` у метода контроллера, этот код хоть и был создан шаблоном, сейчас никак не влияет на работу и не используется.  

![](attachments/Pasted%20image%2020250131104220.png)

После удаления, откроем панель изменений git  

![](attachments/Pasted%20image%2020250131104321.png)

Видим, что git зафиксировал изменения. Но сейчас эти изменения, не зафиксированы, git как бы просто держит эту информацию у себя в памяти, но в локальном репозитории код всё еще в состоянии до удаления кода `(Name = "GetWeatherForecast")`  
Сделаем коммит (фиксацию)  

![](attachments/Pasted%20image%2020250131104536.png)

При нажатии "Зафиксировать все" клиент выполнит команды  
`git add` - чтобы добавить файл в индекс  
`git commit` - чтобы зафиксировать изменения в репозитории  
git клиент уведомляет о том, что фиксация была создана локально. Это значит, что изменения локального репозитория не были отправлены в удаленный.  
Нажмем кнопку `3` отправки в удалённый репозиторий.  
При ее нажатии будет выполнена команда  
`git push origin` - отправить изменения в удаленный репозиторий. origin - это метка которую мы сами выбрали при создании репозитория. На самом деле можно было назвать ее по другому, но обычно все называют origin.  

![](attachments/Pasted%20image%2020250131104834.png)

После отправки гит клиент уведомляет нас, что отправка в удаленный репозиторий произошла успешно и можно создать пул-реквест. Мы сейчас этого делать, не будем т.к. мы хотим сделать всю совместную работу в ветке `cw-01` и потом создать пул-реквест. Пока, что считаем что мы отправили код в удаленный репозиторий для целей бэкапа наших изменений.  

![](attachments/Pasted%20image%2020250131104942.png)

Перейдем на ветку `master`  

![](attachments/Pasted%20image%2020250131105455.png)

Видим что здесь код не удален  

![](attachments/Pasted%20image%2020250131105531.png)

В момент выбора ветки в меню, под капотом выполняется команда `git checkout master`  
Вернемся на ветку `cw-01` - в этот раз поработаем с git через терминал  
Зайдем на вкладку PowerShell для разработчиков - это встроенный в Visual Studio терминал. На самом деле можно было запустить любой клиент вне IDE и сделать тоже самое.  
выполним команду `git status`  
мы находимся на ветке master  
видим, удаленный код на месте  

![](attachments/Pasted%20image%2020250131110224.png)

выполним команду `git checkout cw-01`  
видим, что текущая ветка `cw-01`  
видим, что кода который мы удалили в этой ветке - нет  

![](attachments/Pasted%20image%2020250131110403.png)

На этом завершаем знакомство с git.

# Product и ProductController

[INFO Роуты и эндпоинты](INFO/Роуты%20и%20эндпоинты.md)  

Перед нами стоит задача:  
Сделать метод в API, который будет отображать список товаров как в `WeatherForecastController.cs`  
Создадим в корне `EShop.Presenatation` новый класс `Product`  

![](attachments/Pasted%20image%2020250131110811.png)  
![](attachments/Pasted%20image%2020250131110813.png)

У нашего `Product` будут следующие свойства  
```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}
```

![](attachments/Pasted%20image%2020250131110932.png)

В папке Controllers создадим класс контроллера  

![](attachments/Pasted%20image%2020250131111223.png)  
![](attachments/Pasted%20image%2020250131111307.png)  
![](attachments/Pasted%20image%2020250131111316.png)

Добавим в контроллер, поле - массив из товаров и метод для возврата товаров  
```csharp
[Route("api/[controller]")]
[ApiController]
public class ProductsController : ControllerBase
{
    private Product[] products =
    [
        new Product { Id = 1, Name = "Iphone", Price = 333 },
        new Product { Id = 2, Name = "Iphone1", Price = 444 },
        new Product { Id = 3, Name = "Iphone2", Price = 555 },
        new Product { Id = 4, Name = "Iphone3", Price = 666 },
        new Product { Id = 5, Name = "Iphone4", Price = 777 }
    ];

    [HttpGet]
    public IEnumerable<Product> Get()
    {
        return products;
    }

}
```

![](attachments/Pasted%20image%2020250131113120.png)

Запустим, приложение.  
Видим, что в swagger появился новый метод и он работает  

![](attachments/Pasted%20image%2020250131113258.png)

Зайдем в `EShop.Presentation.http`  
Добавим обращение к `products GET`  
```http
GET {{EShop.Presentation_HostAddress}}/api/Products/  
Accept: application/json
```

Обратим внимание как аттрибут `[Route]` влияет на путь по которому будет доступен эндпоинт  

![](attachments/Pasted%20image%2020250131113902.png)

Удалим файлы:  
```
WeatherForecastController.cs
WeatherForecast.cs
```
и обращение к эндпоинту `GET /weatherforecast/` в `EShop.Presentation.http`  

![](attachments/Pasted%20image%2020250131114201.png)

Зафиксируем изменения и отправим в удаленный репозиторий  

![](attachments/Pasted%20image%2020250131114319.png)  
![](attachments/Pasted%20image%2020250131114422.png)  
![](attachments/Pasted%20image%2020250131114449.png)  
![](attachments/Pasted%20image%2020250131114504.png)

перейдем в браузер и заполним пул-реквест  

![](attachments/Pasted%20image%2020250131114732.png)

1. Указываем целевую ветку - в которую мы будем сливать нашу ветку. У нас ветка cw-01 вливается в master  
2. title - укажем имя ветки  
3. description - коротко опишем какие изменения содержит этот пул-реквест  
4. создаем пул-реквест  
5. сейчас нам не нужно код-ревью - сразу делаем merge pull request.