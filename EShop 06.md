---
created: 2025-02-07-09-39-49+10:00
tags:
---
# Асинхронный код
[INFO Process, Thread & Thread pool](INFO/Process,%20Thread%20&%20Thread%20pool.md)
## Task, async/await
**Task** — объект, представляющий асинхронную операцию (например, запрос к БД, чтение файла).  
**async/await** — ключевые слова C# для работы с асинхронным кодом без блокировки потока.
### Как это работает?
1. **async** помечает метод как асинхронный.
2. **await** приостанавливает выполнение метода, пока не завершится Task, но не блокирует поток.
3. Управление возвращается вызывающему коду, пока Task выполняется.
### Пример:
```csharp
public async Task<string> GetDataAsync()
{
    var data = await HttpClient.GetStringAsync("https://api.example.com/data");
    return data.ToUpper();
}
```
### Основные правила:
- **Async-методы** должны возвращать `Task`, `Task<T>` или `ValueTask<T>`.
- **Не использовать** `async void` (кроме обработчиков событий).
- **Не блокировать** асинхронный код через `.Result` или `.Wait()` (риск deadlock).
### Зачем нужно?
- **Производительность**: Освобождает поток (например, в UI или серверных приложениях) во время операций ввода-вывода.
- **Масштабируемость**: Эффективное использование ресурсов в высоконагруженных системах.
## ProductsController 
Переделаем методы контроллера на асинхронные  
Для этого нужно будет у методов добавить `async` и изменить возвращаемые типы на `Task<T>`  
![](attachments/Pasted%20image%2020250204230648.png)  
Запустим, вызовем методы в Swagger, убедимся что ничего не изменилось  
![](attachments/Pasted%20image%2020250204230743.png)  
Идем внутрь по стеку вызовов  
`ProductHandler`:  
![](attachments/Pasted%20image%2020250204230943.png)  
Так же добавили `async` и `Task<T>`  
Попробуем собрать приложение  
Видим ошибку времени компиляции  
![](attachments/Pasted%20image%2020250204231112.png)  
Проблема в том, что после наших правок методы `_handler` стали возвращать `Task<T>` и код который использует результаты работы хэндлера теперь не валиден - он написан так, как будто там возвращается коллекция товаров, но сейчас будет возвращаться `Task<IEnumerable<Product>>` - коллекция товаров завернутая в "задание", в такое как бы "обещание" быть когда-то полученной коллекцией товаров. 
Для решения этой проблемы нужно добавить `await` в места вызова методов возвращающих `Task`.
Когда мы делали тоже самое в контроллере - проблемы не возникло, т.к. обработчики контроллера разруливают эту проблему на уровне сервера.
Добавим `await` в места вызова асинхронных методов хэндлера  
![](attachments/Pasted%20image%2020250204231934.png)  
Приложение снова заработало  
Не асинхронным остался `IProductRepository` и его имплементация - исправим это  
![](attachments/Pasted%20image%2020250204232135.png)  
В описаниях асинхронных методов интерфейсов нельзя указывать `async` достаточно указать возвращаемый тип - `Task`  
[INFO Почему в интерфейсах без async](INFO/Почему%20в%20интерфейсах%20без%20async.md)  
Переделаем так же на `async` класс `JsonProductRepository`, если оставить его как есть - не скомпилируется приложение т.к. из-за изменения возвращаемого типа интерфейса у нас нарушается контракт.  
В методе заменим вызов `File.ReadAllText` на `File.ReadAllTextAsync` и добавим `awit` остальное оставим как есть. Не все методы должны быть асинхронными, обычно выгода от использования асинхронных операций возникает когда есть IO-bound операции.    
![](attachments/Pasted%20image%2020250204233341.png)  
[INFO IO-bound операции](INFO/IO-bound.md)  
Поправим и `DbProductRepository`  
Изменим сигнатуру метода `Get`
Заменим вызовы `npsql` на асинхронные  
![](attachments/Pasted%20image%2020250207124317.png)
Теперь нужно поправить вызовы методов репозитория  
![](attachments/Pasted%20image%2020250207124354.png)    
Добавим `await` в эти места.
![](attachments/Pasted%20image%2020250207124442.png)  
Запустим приложение, проверим что собирается и работает.  
Таким образом мы провели "рефакторинг" нашего приложения и сделали большинство его методов асинхронными. Правильный асинхронный код требует проброса async/await по всему стеку, поэтому такой рефакторинг бывает трудозатратным, но нам он был необходим так как мы хотим добавить использование БД в наше приложение, работа с БД изобилует IO-bound операциями - каждое обращение в БД, это ввод-вывод.  
# Работа с исключениями
# FluentResult