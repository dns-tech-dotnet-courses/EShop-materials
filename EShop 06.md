---
created: 2025-02-07-09-39-49+10:00
tags:
---
# Асинхронный код
[INFO Process, Thread & Thread pool](INFO/Process,%20Thread%20&%20Thread%20pool.md)
## Task, async/await
**Task** — объект, представляющий асинхронную операцию (например, запрос к БД, чтение файла).  
**async/await** — ключевые слова C# для работы с асинхронным кодом без блокировки потока.
### Как это работает?
1. **async** помечает метод как асинхронный.
2. **await** приостанавливает выполнение метода, пока не завершится Task, но не блокирует поток.
3. Управление возвращается вызывающему коду, пока Task выполняется.
### Пример:
```csharp
public async Task<string> GetDataAsync()
{
    var data = await HttpClient.GetStringAsync("https://api.example.com/data");
    return data.ToUpper();
}
```
### Основные правила:
- **Async-методы** должны возвращать `Task`, `Task<T>` или `ValueTask<T>`.
- **Не использовать** `async void` (кроме обработчиков событий).
- **Не блокировать** асинхронный код через `.Result` или `.Wait()` (риск deadlock).
### Зачем нужно?
- **Производительность**: Освобождает поток (например, в UI или серверных приложениях) во время операций ввода-вывода.
- **Масштабируемость**: Эффективное использование ресурсов в высоконагруженных системах.
## ProductsController 
Переделаем методы контроллера на асинхронные  
Для этого нужно будет у методов добавить `async` и изменить возвращаемые типы на `Task<T>`  
![](attachments/Pasted%20image%2020250204230648.png)  
Запустим, вызовем методы в Swagger, убедимся что ничего не изменилось  
![](attachments/Pasted%20image%2020250204230743.png)  
Идем внутрь по стеку вызовов  
`ProductHandler`:  
![](attachments/Pasted%20image%2020250204230943.png)  
Так же добавили `async` и `Task<T>`  
Попробуем собрать приложение  
Видим ошибку времени компиляции  
![](attachments/Pasted%20image%2020250204231112.png)  
Проблема в том, что после наших правок методы `_handler` стали возвращать `Task<T>` и код который использует результаты работы хэндлера теперь не валиден - он написан так, как будто там возвращается коллекция товаров, но сейчас будет возвращаться `Task<IEnumerable<Product>>` - коллекция товаров завернутая в "задание", в такое как бы "обещание" быть когда-то полученной коллекцией товаров. 
Для решения этой проблемы нужно добавить `await` в места вызова методов возвращающих `Task`.
Когда мы делали тоже самое в контроллере - проблемы не возникло, т.к. обработчики контроллера разруливают эту проблему на уровне сервера.
Добавим `await` в места вызова асинхронных методов хэндлера  
![](attachments/Pasted%20image%2020250204231934.png)  
Приложение снова заработало  
Не асинхронным остался `IProductRepository` и его имплементация - исправим это  
![](attachments/Pasted%20image%2020250204232135.png)  
В описаниях асинхронных методов интерфейсов нельзя указывать `async` достаточно указать возвращаемый тип - `Task`  
[INFO Почему в интерфейсах без async](INFO/Почему%20в%20интерфейсах%20без%20async.md)  
Переделаем так же на `async` класс `JsonProductRepository`, если оставить его как есть - не скомпилируется приложение т.к. из-за изменения возвращаемого типа интерфейса у нас нарушается контракт.  
В методе заменим вызов `File.ReadAllText` на `File.ReadAllTextAsync` и добавим `awit` остальное оставим как есть. Не все методы должны быть асинхронными, обычно выгода от использования асинхронных операций возникает когда есть IO-bound операции.    
![](attachments/Pasted%20image%2020250204233341.png)  
[INFO IO-bound операции](INFO/IO-bound.md)  
Поправим и `DbProductRepository`  
Изменим сигнатуру метода `Get`
Заменим вызовы `npsql` на асинхронные  
![](attachments/Pasted%20image%2020250207124317.png)
Теперь нужно поправить вызовы методов репозитория  
![](attachments/Pasted%20image%2020250207124354.png)    
Добавим `await` в эти места.
![](attachments/Pasted%20image%2020250207124442.png)  
Запустим приложение, проверим что собирается и работает.  
Таким образом мы провели "рефакторинг" нашего приложения и сделали большинство его методов асинхронными. Правильный асинхронный код требует проброса async/await по всему стеку, поэтому такой рефакторинг бывает трудозатратным, но нам он был необходим так как мы хотим добавить использование БД в наше приложение, работа с БД изобилует IO-bound операциями - каждое обращение в БД, это ввод-вывод.  
# Исключения и try catch
Иногда в коде мы пишем операторы, которые предположительно могут вызвать ошибку времени исполнения - при этом какая будет ошибка мы точно не знаем  
Подобное поведение часто возможно, когда мы работаем с какими-то ресурсами вне нашей программы. Например обращаемся в базу данных или отправляем http-запрос  
Когда мы пишем в коде обращение в базу данных, мы ожидаем, что нам вернется определенный тип ответа, но что если база данных просто не запущена?  
Посмотрим на примере  
Остановим контейнер с БД в докере, если он запущен  
![](attachments/Pasted%20image%2020250207130605.png)
Установим брикпоинт в `DbProductRepository`  
![](attachments/Pasted%20image%2020250207130653.png)  
Запустим приложение и вызовем какой-либо метод  
Попадем в брикпоинт  
После выполнения оператора `connection.Open()`  
Вернемся в браузер  
![](attachments/Pasted%20image%2020250207131035.png)  
Видим, что вместо ожидаемого поведения, получили описание какой-то ошибки и стек вызовов, которые привели к этой проблеме.
Объект который мы получили при вызове `connection.Open()` называется исключение (`Exception`).  
Исключения имеют особенный механизм работы.  
Когда вызывается исключение, выполнение программы немедленно прерывается, и если ни один блок `catch` не перехватывает это исключение, оно продолжает подниматься по стеку вызовов, пока не будет обработано, или программа завершится с ошибкой.
[Exception & try catch](INFO/Exception%20&%20try%20catch.md)
Добавим в наш код работы с БД, обработку исключений
Обернем код который работает с БД в оператор try catch
```csharp
try
{
    SomeDangerCode();
}
catch (Exception ex)
{
    DoSomethingWithThisProblem();
} 
```
Сейчас в блоке catch добавим логирование в консоль с более понятным описанием проблемы и посмотрим поведение приложения
![](attachments/Pasted%20image%2020250207133157.png)Выполним любой метод в `Swagger`. 
Обратим внимание, что метод ничего не возвращает, но и не ругается на ошибку  
Посмотрим, что в консоли  
![](attachments/Pasted%20image%2020250207133533.png)  
1 Текст который мы указали  
2 ex.Message  
3 ex.StackTrace  
Получается с помощью try catch мы можем "перехватывать" исключения и затем совершать какие-то действия понимания, что мы находимся в "исключительной ситуации"  
Сейчас при исключении мы возвращаем пустой список и логируем ошибку в консоль  

# Работа с исключениями
Давайте порассуждаем - клиент АПИ обращается за списком товаров, ожидая, что мы проверим запрошенные товары в своей БД  и вернем ему результат. Но если мы со своей стороны обратились в БД, но не смогли получить от неё ответ - можем ли мы ответить, что у нас нет товаров? Ведь в реальности мы не знаем - мы не смогли опросить БД.  
Если клиент построит на таком ответе свою логику - может появится скрытая "угроза". Где-то в цепочке общения систем возникает ошибка, но она скрывается обработкой исключения - это может стать очень запутанной проблемой и нанести урон бизнесу.
Может подуматься, что тогда вообще не стоит использовать обработку исключений, но это не так - бросать "голые исключения" также может быть некорректно. Например мы "выставляем" наружу подробности нашей реализации - при исключении видно StackTrace.
[INFO Почему плохо бросать исключения](INFO/Почему%20плохо%20бросать%20исключения.md)
## Pattern Result
Нет четкого ответа, как нужно поступать в каждом конкретном случае  
Рассмотрим один из вариантов работы с такой проблемой - паттерн Result  
[INFO Pattern Result](INFO/Pattern%20Result.md)  
## FluentResult
В dotnet существует пакет https://github.com/altmann/FluentResults который является реализацией паттерна Result  
Подключим пакет во все решение  
![](attachments/Pasted%20image%2020250207152542.png)  
![](attachments/Pasted%20image%2020250207152635.png)  
Мы хотим чтобы все также возвращал Task, т.к. у нас асинхронный метод. А вот результат т.е. коллекцию Product, еще завернем дополнительно в Result, что бы иметь возможность понять успешно ли выполнился метод или что-то пошло не так.
Добавляем обёртку  
Изменим сигнатуру на 
```csharp
public async Task<Result<IEnumerable<Product>>> Get()
```
давайте детально разберем её  
Метод помечен асинхронным, возвращает Task, которая будет содержать в себе Result, в котором будет коллекция Product. 
Особенность и главная фича Result, в том, что если метод отработал как-то криво, мы можем сказать Result неуспешный, и добавить в пояснение описание ошибки. Или если всё хорошо можем вернуть в нем значение.  
У нас сейчас возникла проблема - сигнатура метода не совпадет с контрактом, поэтому поправим интерфейс - он теперь тоже будет обязывать возвращать Result
![](attachments/Pasted%20image%2020250207153612.png)  